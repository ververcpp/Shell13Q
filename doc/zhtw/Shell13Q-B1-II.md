##B1-II. [^ ] 跟 [! ] 差在哪？(Regular Expression)

接下來的 Regular Expression(RE) 可是個大題目, 要講的很多, 我這裡當然不可能講得很完全.
只希望帶給大家一個基本的入門概念, 就很是足夠了...

先來考一下英文好了: What is expression?  
簡單來說, 就是"表達", 也就是人們在溝通時所要陳述的內容.  
然而, 生活中, 表達方要清楚的將意思描述清楚而讓接收方完整且無誤的領會, 可不是件容易的事情.  
因而才會出現那麼多的"誤會", 真可嘆句"表達不易"啊....  
同樣的情形也發生在電腦的資料處理過程中, 尤其是當我們在描術一段"文字內容"的時候...  
那麼, 我們不禁要問: 有何方法可以讓大家的誤會降至最低程度而讓表達的精確度達到最高程度呢?  
答案就是"標準化"了, 亦就是我們這裡要談的 Regular Expression 啦....  ^_^

然而, 在進入 RE 介紹之前, 不防先讓我們溫習一下 shell 十三問第 4 問, 也就是關於 quoting 的部份.
關鍵是要能夠區分 shell command line 上的 meta 與 literal 這兩種不同的字符類別.
然後, 我這裡才跟你講:  
--- RE 表達式裡的字符也是分為 meta 與 literal 這兩種!  
呵, 不知親愛的讀者是否被我搞混亂了呢? ...  ^_^  
這也難怪啦, 因為這的確是最容易混亂的地方, 剛學 RE 的朋友很多時候都死在這裡!
因此請特別小心理解哦...  
簡單而言, 除非你將 RE 寫在特定程式使用的腳本裡,
否則, 我們的 RE 也是透過 command line 輸入的.
然而, 不少 RE 所始用的 meta 字符, 跟 shell meta 字符是衝突的.
比方說, * 這個字符, 在 RE 裡是一個 modifier(後述), 在 command line 上, 卻是個 wildcard !

那麼, 我們該如何解決這樣的衝突呢? 關鍵就是看你對十三問第 4 問所提的 quoting 是否夠理解了!  
若你明白到 shell quoting 就是在 command line 上關閉 shell meta 這一基本原理,
那你就能很輕鬆的解決 RE meta 與 shell meta 的衝突問題了:  
--- 用 shell quoting 關掉 shell meta 就是了!  
就這麼簡單...  ^_^  
再以剛提到的 * 字符為例, 若在 command line 中沒有 quoting 處理的話, 如 abc* , 
那就會被作為 wildcard expansion 來擴充及重組了.  
若將之置於 quoting 中, 如 "abc*", 則可避免 wildcard expansion 的處理.

好了, 說了大半天, 還沒進入正式的 RE 介紹呢...   
大家別急, 因為我的教學風格就是要先建立基礎, 循序漸進的...  ^_^  
因此, 我這裡還要在囉唆一個觀念, 才會到 RE 的說明啦... (哈... 別打我....)  
當我們在談到 RE 時, 千萬別跟 wildcard 搞混在一起!  
尤其在 command line 的位置裡, wildcard 只作用於 argument 的 path 上.  
但是 RE 卻只用於"字串處理"的程式之中, 這與路逕名稱一點關系也沒有!  
RE 所處理的字串通常是指純文檔或透過 stdin 讀進的內容...

okay, 夠了夠了, 我已看到一堆人開始出現不大耐煩的樣子了....  ^_^  
現在, 就讓我門登堂入室, 撩開 RE 的神秘面紗吧, 這樣可以放過我了吧? 哈哈...

在 RE 的表達式裡, 主要分兩種字符(character): literal 與 meta.  
所謂 literal 就是在 RE 裡不具特殊功能的字符, 如 abc, 123 這些;  
而 meta 在 RE 裡具有特殊的功能, 要關閉之, 需在 meta 前面使用 escape( \ )字符.  

然而, 在介紹 meta 之前, 先讓我們來認識一下字符組合(character set)會更好些.  
所謂的 char. set 就是將多個連續的字符作一個集合, 比方說:

* abc: 表示 abc 三個連續的字符, 但彼此獨立而非集合. (可簡單視為三個 char. set)
* (abc): 表示 abc 這三個連續字符的集合. (可簡單視為一個 char. set)
* abc|xyz: 表示或 abc 或 xyz 這兩個 char. set 之一. 
* [abc]: 表示單一字符, 可為 a 或 b 或 c . (與 wildcard 之 [abc] 原理相同)
* [^abc]: 表示單一字符, 不為 a 或 b 或 c 即可. (與 wildcard 之 [!abc] 原理相同)
* . : 表示任意單一字符. (與 wildcard 之 ? 原理相同)

在認識了 char. set 這個概念後, 然後再讓我們多認識幾個 RE 中常見的 meta 字符:

> 錨點(anchor)  
用以標識 RE 於句子中的位置所在. 常見有:
* ^: 表示句首. 如 ^abc 表示以 abc 開首的句子.
* $: 表示句尾. 如 abc$ 表示以 abc 結尾的句子.
* \<: 表示詞首. 如 \<abc 表示以 abc 開首的詞.
* \>: 表示詞尾. 如 abc\> 表示以 abc 結尾的詞.

> 修飾字符(modifier)  
獨立表示時本身不具意義, 專門用以修改前一個 char. set 的出現次數. 常見有:
* \*: 表示前一個 char. set 的出現次數為 0 或多次. 如 ab*c 表示 a 與 c 之間可有 0 或多個 b 存在.
* ?: 表示前一個 char. set 的出現次數為 0 或 1 次. 如 ab?c 表示 a 與 c 之間可有 0 或 1 個 b 存在.
* +: 表示前一個 char. set 的出現次數為 1 或多次. 如 ab+c 表示 a 與 c 之間可有 1 或多個 b 存在.
* {n}: 表示前一個 char. set 的出現次數必須為 n 次. 如 ab{3}c 表示 a 與 c 之間必須有 3 個 b 存在.
* {n,}: 表示前一個 char. set 的出現次數至少為 n 次. 如 ab{3,}c 表示 a 與 c 之間至少有 3 個 b 存在.
* {n,m}: 表示前一個 char. set 的出現次數為 n 到 m 次. 如 ab{3,5}c 表示 a 與 c 之間有 3 到 5 個 b 存在.

然而, 當我們在識別 modifier 時, 卻很容易忽略"邊界(boundary)"字符的重要性.  
以剛提到的 ab{3,5}c 為例, 這裡的 a 與 c 就是邊界字符了.  
若沒有邊界字符的幫忙, 我們很容以作出錯誤的解讀.  
比方說: 我們用 ab{3,5} 這個 RE (少了 c 這個邊界字符)可以抓到 abbbbbbbbbbc (a 後有 10 個 b )這串字嗎?  
從剛才的 modifier 我們一般會認為我們要的 b 是 3 到 5 個, 若超出了此範圍, 就不是我們要表達的.  
因此, 我們或會很輕率的認為這個 RE 抓不到結果（上述“ａbbbbbbbbbbc”字串）...  
然而答案卻是可以的! 為甚麼呢?  
讓我們重新解讀 ab{3,5} 這個 RE 看看:  
我們要表達的是 a 後接 3 到 5 個 b 即可, 但 3 到 5 個 b 後面我們卻沒規定是甚麼, 
因此在 RE 後面可以是任意的文字, 當然包括 b 也可以啦! (明白了嗎?)  
同樣的, 我們用 b{3,5}c 也同樣可以抓到 abbbbbbbbbbc 這串字的.  
但我們若使用 ab{3,5}c 這樣的 RE 時, 由於同時有 a 與 c 這兩個邊界字符, 那就截然不同了!  

有空再思考一下, 為何我們用下面這些 RE 都可抓到 abc 這串字呢?  
x*  
ax*, abx*, ax*b  
abcx*, abx*c, ax*bc  
bx*c, bcx*, x*bc  
...(還有更多...)  
但, 若我們在這些 RE 前後分別加一個 ^ 與 $ 這樣的 anchor, 那又如何呢?

剛學 RE 時, 只要能掌握上面這些基本的 meta 大蓋就可以入門了.
一如前述, RE 是一種規範化的文字表達方式, 主要用於某些文字處理工具之間,
如 `grep`, `perl`, `vi`, `awk`, `sed`, 等等. 常用以表示一段連續的字串, 捕獲之或替換之.
然而, 每種工具對 RE 表達式的具體解讀或有一些細微差異, 不過, 基本原則還是一致的.
只要能掌握 RE 的基本原理, 那就一理通百理明了, 只是在實作時稍加變通即可. 

比方以 `grep` 來說, 在 Linux 上你可找到 `grep`, `egrep`, `fgrep` 這幾個程式, 其差異大致如下:

**`grep`:**

傳統的 `grep` 程式, 在沒有參數的情況下, 只輸出符合 RE 字串之句子. 常見參數如下:
* -v: 逆反模示, 只輸出"不含" RE 字串之句子.
* -r: 遞迴模式, 可同時處理所有層級子目錄裡的文件.
* -q: 靜默模式, 不輸出任何結果(`stderr` 除外. 常用以獲取 return value, 符合為 `true`, 否則為 `false` .)
* -i: 忽略大小寫.
* -w: 整詞比對, 類似 \<word\> .
* -n: 同時輸出行號.
* -c: 只輸出符合比對的行數.
* -l: 只輸出符合比對的文件名稱.
* -o: 只輸出符合 RE 的字串. (gnu 新版獨有, 不見得所有版本都支持.)
* -E: 切換為 `egrep` .

**`egrep`:**

為 `grep` 的擴充版本, 改良了許多傳統 `grep` 不能或不便的操作. 比方說:
- `grep` 之下不支持 ? 與 + 這兩種 modifier, 但 `egrep` 則可.
- `grep` 不支持 a|b 或 (abc|xyz) 這類"或一"比對, 但 `egrep` 則可.
- `grep` 在處理 {n,m} 時, 需用 \{ 與 \} 處理, 但 `egrep` 則不需.
諸如此類的... 我個人會建議能用 `egrep` 就不用 `grep` 啦...  ^_^

**`fgrep`:**

不作 RE 處理, 表達式僅作一般字串處理, 所有 meta 均失去功能.

好了...
關於 RE 的入門, 我暫時就介紹到這裡. 
雖然寫得有點亂, 且有些觀念也不很精確, 不過, 姑且算是對大家有一個交差吧.... ^_^
若這兩天還有時間的話, 我再舉些範例來分析一下, 以助大家更好的理解. 
假如更有可能的話, 也順道為大家介紹一下 `sed` 這個工具.
(啊, 這次我不敢作保證了哦... ^_^ )